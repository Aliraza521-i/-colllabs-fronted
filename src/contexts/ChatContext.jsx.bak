import React, { createContext, useContext, useEffect, useState, useRef, useCallback } from 'react';
import { io } from 'socket.io-client';
import { useAuth } from './AuthContext';
import { chatAPI, adminAPI } from '../services/api';

const ChatContext = createContext();

export const useChat = () => {
  const context = useContext(ChatContext);
  if (!context) {
    throw new Error('useChat must be used within a ChatProvider');
  }
  return context;
};

export const ChatProvider = ({ children }) => {
  const { user, token, isPublisher, isAdvertiser, isAdmin } = useAuth();
  const [socket, setSocket] = useState(null);
  const [isConnected, setIsConnected] = useState(false);
  const [chats, setChats] = useState([]);
  const [activeChat, setActiveChat] = useState(null);
  const [messages, setMessages] = useState({});
  const [onlineUsers, setOnlineUsers] = useState([]);
  const [typingUsers, setTypingUsers] = useState({});
  const [unreadCounts, setUnreadCounts] = useState({});
  // Removed notifications state
  // New state for tracking highlighted chats
  const [highlightedChats, setHighlightedChats] = useState({});

  const reconnectTimeoutRef = useRef(null);
  const reconnectAttemptsRef = useRef(0);
  const maxReconnectAttempts = 5;
  const socketRef = useRef(null);

  // Chat management functions
  const joinChat = useCallback((chatId) => {
    if (socketRef.current && socketRef.current.connected) {
      socketRef.current.emit('join_chat', { chatId });
      setActiveChat(chatId);
      
      // Clear unread count for this chat
      setUnreadCounts(prev => ({
        ...prev,
        [chatId]: 0
      }));
      
      // Remove highlight when user opens the chat
      setHighlightedChats(prev => ({
        ...prev,
        [chatId]: false
      }));
    }
  }, []);

  const leaveChat = useCallback((chatId) => {
    if (socketRef.current && socketRef.current.connected) {
      socketRef.current.emit('leave_chat', { chatId });
      if (activeChat === chatId) {
        setActiveChat(null);
      }
    }
  }, [activeChat]);

  const sendMessage = useCallback((chatId, content, type = 'text', replyTo = null, attachments = []) => {
    if (socketRef.current && socketRef.current.connected && content.trim()) {
      const messageData = {
        chatId,
        content: content.trim(),
        type,
        replyTo,
        attachments
      };
      
      socketRef.current.emit('send_message', messageData);
    }
  }, []);

  const startTyping = useCallback((chatId) => {
    if (socketRef.current && socketRef.current.connected) {
      socketRef.current.emit('typing_start', { chatId });
    }
  }, []);

  const stopTyping = useCallback((chatId) => {
    if (socketRef.current && socketRef.current.connected) {
      socketRef.current.emit('typing_stop', { chatId });
    }
  }, []);

  const markAsRead = useCallback((chatId, messageIds) => {
    if (socketRef.current && socketRef.current.connected) {
      socketRef.current.emit('mark_as_read', { chatId, messageIds });
      
      // Update local state
      setUnreadCounts(prev => ({
        ...prev,
        [chatId]: 0 // Reset unread count for this chat
      }));
    }
  }, []);

  const getTypingUsersText = useCallback((chatId) => {
    const typing = typingUsers[chatId] || {};
    const users = Object.values(typing);
    
    if (users.length === 0) return '';
    if (users.length === 1) return `${users[0]} is typing...`;
    if (users.length === 2) return `${users[0]} and ${users[1]} are typing...`;
    return `${users[0]} and ${users.length - 1} others are typing...`;
  }, [typingUsers]);

  const isUserOnline = useCallback((userId) => {
    return onlineUsers.some(user => user.userId === userId && user.status === 'online');
  }, [onlineUsers]);

  const getChatMessages = useCallback((chatId) => {
    return messages[chatId] || [];
  }, [messages]);

  const getTotalUnreadCount = useCallback(() => {
    return Object.values(unreadCounts).reduce((total, count) => total + count, 0);
  }, [unreadCounts]);

  const loadChats = useCallback(async () => {
    try {
      let response;
      
      // If user is admin, fetch all chats using adminAPI
      if (user && user.role === 'admin') {
        response = await adminAPI.getAllChats();
      } else if (user) {
        // For non-admin users, use regular chatAPI
        response = await chatAPI.getChats();
      } else {
        // No user, return empty array
        setChats([]);
        return;
      }
      
      if (response.data && response.data.ok) {
        setChats(response.data.data);
      } else {
        // If response is not ok, set empty array
        setChats([]);
      }
    } catch (error) {
      console.error('Error loading chats:', error);
      // On error, set empty array to avoid undefined state
      setChats([]);
    }
  }, [user]);

  // Memoize connectSocket to prevent recreation on every render
  const connectSocket = useCallback(() => {
    // If already connected, don't reconnect
    if (socketRef.current?.connected) return;

    // Clean up existing socket
    if (socketRef.current) {
      socketRef.current.disconnect();
    }

    // Use import.meta.env instead of process.env for Vite
    // Added defensive coding to prevent "process is not defined" error
    let serverUrl = 'http://localhost:3000';
    
    try {
      // Check if import.meta.env is available (more compatible approach)
      if (import.meta && import.meta.env && import.meta.env.VITE_API_BASE_URL) {
        const baseUrl = import.meta.env.VITE_API_BASE_URL;
        serverUrl = baseUrl.replace('/api/v1', '') || serverUrl;
      }
    } catch (error) {
      console.warn('Could not access environment variables, using default URL:', error);
    }
    
    const socketInstance = io(serverUrl, {
      auth: {
        token: token
      },
      autoConnect: true,
      reconnection: true,
      reconnectionAttempts: maxReconnectAttempts,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      timeout: 20000
    });

    socketRef.current = socketInstance;
    setSocket(socketInstance);

    socketInstance.on('connect', () => {
      console.log('‚úÖ Connected to chat server');
      setIsConnected(true);
      reconnectAttemptsRef.current = 0;
      
      // Request online users
      socketInstance.emit('get_online_users');
    });

    socketInstance.on('disconnect', (reason) => {
      console.log('‚ùå Disconnected from chat server:', reason);
      setIsConnected(false);
      
      // Attempt to reconnect if not intentional
      if (reason !== 'io client disconnect') {
        if (reconnectAttemptsRef.current < maxReconnectAttempts) {
          reconnectTimeoutRef.current = setTimeout(() => {
            console.log(`Attempting to reconnect... (${reconnectAttemptsRef.current + 1}/${maxReconnectAttempts})`);
            reconnectAttemptsRef.current++;
            connectSocket();
          }, 1000 * reconnectAttemptsRef.current); // Exponential backoff
        }
      }
    });

    socketInstance.on('reconnect', (attemptNumber) => {
      console.log(`‚úÖ Reconnected to chat server (attempt ${attemptNumber})`);
      setIsConnected(true);
      reconnectAttemptsRef.current = 0;
    });

    socketInstance.on('reconnect_attempt', (attemptNumber) => {
      console.log(`üîÑ Attempting to reconnect... (${attemptNumber}/${maxReconnectAttempts})`);
    });

    socketInstance.on('reconnect_failed', () => {
      console.log('‚ùå Failed to reconnect after maximum attempts');
      setIsConnected(false);
    });

    socketInstance.on('connect_error', (error) => {
      console.error('‚ùå Connection error:', error);
      setIsConnected(false);
    });

    // Chat events
    socketInstance.on('chat_list', (chats) => {
      setChats(chats);
    });

    socketInstance.on('online_users', (users) => {
      setOnlineUsers(users);
    });

    socketInstance.on('chat_created', (chat) => {
      setChats(prev => [chat, ...prev]);
      
      // Highlight the new chat for better visibility
      setHighlightedChats(prev => ({
        ...prev,
        [chat._id]: true
      }));
      
      // Remove highlight after 5 seconds
      setTimeout(() => {
        setHighlightedChats(prev => ({
          ...prev,
          [chat._id]: false
        }));
      }, 5000);
    });

    socketInstance.on('message', (message) => {
      const { chatId } = message;
      
      // Update messages for this chat
      setMessages(prev => ({
        ...prev,
        [chatId]: prev[chatId] ? [...prev[chatId], message] : [message]
      }));
      
      // Update chat list to show latest message
      setChats(prev => {
        const chatIndex = prev.findIndex(chat => chat._id === chatId);
        if (chatIndex === -1) return prev;
        
        const updatedChats = [...prev];
        const updatedChat = {
          ...updatedChats[chatIndex],
          lastMessage: message.content,
          lastActivity: message.timestamp,
          unreadCount: activeChat === chatId ? 0 : (updatedChats[chatIndex].unreadCount || 0) + 1
        };
        
        // Move updated chat to top
        updatedChats.splice(chatIndex, 1);
        updatedChats.unshift(updatedChat);
        
        return updatedChats;
      });
      
      // Update unread counts if this chat is not currently active
      if (activeChat !== chatId) {
        setUnreadCounts(prev => ({
          ...prev,
          [chatId]: (prev[chatId] || 0) + 1
        }));
        
        // Highlight the chat with new message
        setHighlightedChats(prev => ({
          ...prev,
          [chatId]: true
        }));
        
        // Remove highlight after 5 seconds
        setTimeout(() => {
          setHighlightedChats(prev => ({
            ...prev,
            [chatId]: false
          }));
        }, 5000);
      }
    });

    socketInstance.on('typing_start', ({ chatId, userId, userName }) => {
      setTypingUsers(prev => ({
        ...prev,
        [chatId]: {
          ...prev[chatId],
          [userId]: userName
        }
      }));
    });

    socketInstance.on('typing_stop', ({ chatId, userId }) => {
      setTypingUsers(prev => {
        const updated = { ...prev };
        if (updated[chatId]) {
          delete updated[chatId][userId];
          if (Object.keys(updated[chatId]).length === 0) {
            delete updated[chatId];
          }
        }
        return updated;
      });
    });

    socketInstance.on('message_read', ({ chatId, messageIds }) => {
      // Update message read status
      setMessages(prev => ({
        ...prev,
        [chatId]: prev[chatId]?.map(msg => 
          messageIds.includes(msg._id) ? { ...msg, read: true } : msg
        ) || []
      }));
    });

    socketInstance.on('chat_updated', (updatedChat) => {
      setChats(prev => 
        prev.map(chat => 
          chat._id === updatedChat._id ? updatedChat : chat
        )
      );
    });

    socketInstance.on('message_updated', ({ chatId, messageId, updates }) => {
      setMessages(prev => ({
        ...prev,
        [chatId]: prev[chatId]?.map(msg => 
          msg._id === messageId ? { ...msg, ...updates } : msg
        ) || []
      }));
    });

    socketInstance.on('chat_deleted', (chatId) => {
      setChats(prev => prev.filter(chat => chat._id !== chatId));
      setMessages(prev => {
        const updated = { ...prev };
        delete updated[chatId];
        return updated;
      });
      if (activeChat === chatId) {
        setActiveChat(null);
      }
    });

    socketInstance.on('message_deleted', ({ chatId, messageId }) => {
      setMessages(prev => ({
        ...prev,
        [chatId]: prev[chatId]?.filter(msg => msg._id !== messageId) || []
      }));
    });

    socketInstance.on('last_message_updated', ({ chatId, lastMessage, lastActivity }) => {
      setChats(prev => {
        // Find the chat and update its last message
        const updatedChats = prev.map(chat => 
          chat._id === chatId 
            ? { 
                ...chat, 
                lastMessage, 
                lastActivity 
              }
            : chat
        );
        
        // Move the updated chat to the beginning of the array
        const chatIndex = updatedChats.findIndex(chat => chat._id === chatId);
        if (chatIndex > -1) {
          const [updatedChat] = updatedChats.splice(chatIndex, 1);
          updatedChats.unshift(updatedChat);
        }
        
        return updatedChats;
      });
    });

    // File upload progress
    socketInstance.on('file_upload_progress', (data) => {
      // Handle file upload progress updates
      console.log('File upload progress:', data);
    });

    // Error handling
    socketInstance.on('error', (error) => {
      console.error('Socket error:', error);
      // You could show a toast notification here
    });
  }

  const disconnectSocket = useCallback(() => {
    if (socketRef.current) {
      socketRef.current.disconnect();
      socketRef.current = null;
      setSocket(null);
      setIsConnected(false);
    }
    
    // Clear any pending reconnection attempts
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
      reconnectTimeoutRef.current = null;
    }
    
    // Reset reconnection attempts counter
    reconnectAttemptsRef.current = 0;
  }, []);

  useEffect(() => {
    if (user && token) {
      connectSocket();
      loadChats();
    } else {
      disconnectSocket();
    }

    return () => {
      disconnectSocket();
    };
  }, [user, token, connectSocket, disconnectSocket, loadChats]);

  const value = {
    // Connection state
    socket,
    isConnected,
    
    // Chat data
    chats,
    setChats,
    activeChat,
    messages,
    onlineUsers,
    typingUsers,
    unreadCounts,
    // Removed notifications
    highlightedChats, // Expose highlighted chats state
    setHighlightedChats, // Expose function to update highlighted chats
    
    // Actions
    joinChat,
    leaveChat,
    sendMessage,
    startTyping,
    stopTyping,
    markAsRead,
    
    // Utilities
    getTypingUsersText,
    isUserOnline,
    getChatMessages,
    getTotalUnreadCount,
    loadChats,
    
    // Connection management
    connectSocket,
    disconnectSocket
  };

  return (
    <ChatContext.Provider value={value}>
      {children}
    </ChatContext.Provider>
  );
};